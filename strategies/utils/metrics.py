"""
Custom business metrics for realtime strategies monitoring.

This module provides OpenTelemetry-based metrics for monitoring:
- Message processing rates
- Strategy execution latency
- Signal generation
- Consumer lag
"""

import time
from typing import Optional

from opentelemetry import metrics

# Import get_meter from petrosa_otel package
try:
    from petrosa_otel import get_meter
except ImportError:
    # Fallback if petrosa_otel not available
    def get_meter(name: str) -> metrics.Meter:
        return metrics.get_meter(name)


class RealtimeStrategyMetrics:
    """
    OpenTelemetry metrics for realtime strategies.

    Provides counters, histograms, and gauges for monitoring strategy performance.
    """

    def __init__(self, meter_name: str = "petrosa.realtime.strategies"):
        """
        Initialize metrics.

        Args:
            meter_name: Name for the OpenTelemetry meter
        """
        self.meter = get_meter(meter_name)

        # NATS message processing counter
        self.messages_processed = self.meter.create_counter(
            name="realtime.messages.processed",
            description="Total number of NATS messages processed",
            unit="1",
        )

        # NATS message processing latency histogram
        self.message_latency = self.meter.create_histogram(
            name="realtime.message.processing_latency",
            description="NATS message processing latency in milliseconds",
            unit="ms",
        )

        # Strategy execution latency histogram
        self.strategy_latency = self.meter.create_histogram(
            name="realtime.strategy.latency",
            description="Strategy execution latency in milliseconds",
            unit="ms",
        )

        # NATS consumer lag gauge (observable/async gauge)
        self._consumer_lag_value: float = 0.0
        self.consumer_lag = self.meter.create_observable_gauge(
            name="realtime.consumer.lag",
            callbacks=[self._get_consumer_lag],
            description="NATS consumer lag in seconds",
            unit="s",
        )

        # Strategy result counter (buy/sell/hold signals)
        self.signals_generated = self.meter.create_counter(
            name="realtime.signals.generated",
            description="Total number of signals generated by strategy",
            unit="1",
        )

        # Error counter
        self.errors_total = self.meter.create_counter(
            name="realtime.errors.total",
            description="Total number of errors during message processing",
            unit="1",
        )

        # Message type counter (depth/trade/ticker)
        self.message_types = self.meter.create_counter(
            name="realtime.message.types",
            description="Messages received by type",
            unit="1",
        )

        # Strategy execution counter (success/failure)
        self.strategy_executions = self.meter.create_counter(
            name="realtime.strategy.executions",
            description="Strategy executions by result",
            unit="1",
        )

        # Configuration change counter
        self.config_changes = self.meter.create_counter(
            name="realtime.config.changes",
            description="Total number of strategy configuration changes",
            unit="1",
        )

        # Market metrics processing counter
        self.market_metrics_processed = self.meter.create_counter(
            name="realtime.market_metrics.processed",
            description="Total number of market metrics (depth, pressure) calculated",
            unit="1",
        )

    def _get_consumer_lag(self, options: metrics.CallbackOptions):
        """
        Callback for observable gauge to get current consumer lag.

        Args:
            options: OpenTelemetry callback options
        """
        yield metrics.Observation(self._consumer_lag_value)

    def record_message_processed(
        self, symbol: str, message_type: str, strategy: str | None = None
    ):
        """
        Record a processed message.

        Args:
            symbol: Trading symbol (e.g., "BTCUSDT")
            message_type: Type of message ("depth", "trade", "ticker")
            strategy: Strategy name (optional)
        """
        attributes = {
            "symbol": symbol,
            "message_type": message_type,
        }
        if strategy:
            attributes["strategy"] = strategy

        self.messages_processed.add(1, attributes=attributes)

    def record_message_type(self, message_type: str):
        """
        Record message type received.

        Args:
            message_type: Type of message ("depth", "trade", "ticker")
        """
        self.message_types.add(1, attributes={"type": message_type})

    def record_message_latency(self, latency_ms: float, message_type: str):
        """
        Record NATS message processing latency.

        Args:
            latency_ms: Latency in milliseconds
            message_type: Type of message ("depth", "trade", "ticker")
        """
        self.message_latency.record(
            latency_ms, attributes={"message_type": message_type}
        )

    def record_strategy_latency(
        self, strategy: str, latency_ms: float, symbol: str | None = None
    ):
        """
        Record strategy execution latency.

        Args:
            strategy: Strategy name
            latency_ms: Latency in milliseconds
            symbol: Trading symbol (optional)
        """
        attributes = {"strategy": strategy}
        if symbol:
            attributes["symbol"] = symbol

        self.strategy_latency.record(latency_ms, attributes=attributes)

    def record_strategy_execution(self, strategy: str, result: str, symbol: str):
        """
        Record strategy execution result.

        Args:
            strategy: Strategy name
            result: Execution result ("success", "failure", "no_signal")
            symbol: Trading symbol
        """
        self.strategy_executions.add(
            1, attributes={"strategy": strategy, "result": result, "symbol": symbol}
        )

    def record_signal_generated(
        self,
        strategy: str,
        signal_type: str,
        symbol: str,
        confidence: float,
        action: str | None = None,
    ):
        """
        Record a generated signal.

        Args:
            strategy: Strategy name
            signal_type: Signal type ("buy", "sell", "hold")
            symbol: Trading symbol
            confidence: Signal confidence (0.0-1.0)
            action: Specific action (optional)
        """
        attributes = {
            "strategy": strategy,
            "signal_type": signal_type.lower(),
            "symbol": symbol,
            "confidence_bucket": self._get_confidence_bucket(confidence),
        }
        if action:
            attributes["action"] = action

        self.signals_generated.add(1, attributes=attributes)

    def record_config_change(self, strategy_id: str, symbol: str | None, action: str):
        """
        Record a configuration change.

        Args:
            strategy_id: Strategy identifier
            symbol: Trading symbol (optional)
            action: Action type ("CREATE", "UPDATE", "DELETE", "ROLLBACK")
        """
        attributes = {
            "strategy_id": strategy_id,
            "action": action,
        }
        if symbol:
            attributes["symbol"] = symbol
        else:
            attributes["symbol"] = "global"

        self.config_changes.add(1, attributes=attributes)

    def record_market_metrics_processed(self, symbol: str, metric_type: str = "depth"):
        """
        Record market metrics calculation.

        Args:
            symbol: Trading symbol
            metric_type: Type of metric ("depth", "pressure", etc.)
        """
        self.market_metrics_processed.add(
            1, attributes={"symbol": symbol, "metric_type": metric_type}
        )

    def record_error(self, error_type: str, strategy: str | None = None):
        """
        Record an error.

        Args:
            error_type: Type of error
            strategy: Strategy name (optional)
        """
        attributes = {"error_type": error_type}
        if strategy:
            attributes["strategy"] = strategy

        self.errors_total.add(1, attributes=attributes)

    def update_consumer_lag(self, lag_seconds: float):
        """
        Update consumer lag value.

        Args:
            lag_seconds: Consumer lag in seconds
        """
        self._consumer_lag_value = lag_seconds

    @staticmethod
    def _get_confidence_bucket(confidence: float) -> str:
        """
        Get confidence bucket for grouping signals.

        Args:
            confidence: Signal confidence (0.0-1.0)

        Returns:
            Confidence bucket label
        """
        if confidence >= 0.9:
            return "very_high"
        elif confidence >= 0.75:
            return "high"
        elif confidence >= 0.5:
            return "medium"
        else:
            return "low"


# Global metrics instance (initialized by consumer)
_metrics: RealtimeStrategyMetrics | None = None


def initialize_metrics() -> RealtimeStrategyMetrics:
    """
    Initialize global metrics instance.

    Returns:
        Metrics instance
    """
    global _metrics
    if _metrics is None:
        _metrics = RealtimeStrategyMetrics()
    return _metrics


def get_metrics() -> RealtimeStrategyMetrics | None:
    """
    Get global metrics instance.

    Returns:
        Metrics instance or None if not initialized
    """
    return _metrics


class MetricsContext:
    """
    Context manager for timing strategy execution.

    Example:
        with MetricsContext(strategy="orderbook_skew", symbol="BTCUSDT") as ctx:
            # Process strategy
            signal = process_orderbook_skew(data)

            # Record signal if generated
            if signal:
                ctx.record_signal(
                    signal.signal_type.value,
                    signal.confidence_score,
                    signal.signal_action.value
                )
    """

    def __init__(
        self,
        strategy: str,
        symbol: str,
        metrics: RealtimeStrategyMetrics | None = None,
    ):
        """
        Initialize metrics context.

        Args:
            strategy: Strategy name
            symbol: Trading symbol
            metrics: Metrics instance (uses global if not provided)
        """
        self.strategy = strategy
        self.symbol = symbol
        self.metrics = metrics or get_metrics()
        self.start_time: float | None = None
        self.signal_recorded = False

    def __enter__(self):
        """Start timing."""
        self.start_time = time.time()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Record latency and execution result."""
        if self.metrics and self.start_time:
            latency_ms = (time.time() - self.start_time) * 1000

            # Record latency
            self.metrics.record_strategy_latency(self.strategy, latency_ms, self.symbol)

            # Record execution result
            if exc_type:
                self.metrics.record_strategy_execution(
                    self.strategy, "failure", self.symbol
                )
                self.metrics.record_error("strategy_execution", self.strategy)
            elif self.signal_recorded:
                self.metrics.record_strategy_execution(
                    self.strategy, "success", self.symbol
                )
            else:
                self.metrics.record_strategy_execution(
                    self.strategy, "no_signal", self.symbol
                )

        # Don't suppress exceptions
        return False

    def record_signal(
        self, signal_type: str, confidence: float, action: str | None = None
    ):
        """
        Record signal generation.

        Args:
            signal_type: Signal type ("buy", "sell", "hold")
            confidence: Signal confidence (0.0-1.0)
            action: Specific action (optional)
        """
        if self.metrics:
            self.metrics.record_signal_generated(
                self.strategy, signal_type, self.symbol, confidence, action
            )
            self.signal_recorded = True

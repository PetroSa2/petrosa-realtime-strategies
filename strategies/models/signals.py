"""
Signal models for trading signals generated by strategies.

This module contains Pydantic models for representing trading signals,
signal types, confidence levels, and strategy-specific signals.
"""

from datetime import datetime
from enum import Enum
from typing import Any, Optional

from pydantic import BaseModel, Field, validator


class SignalType(str, Enum):
    """Types of trading signals."""

    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class SignalAction(str, Enum):
    """Actions to take based on signals."""

    OPEN_LONG = "OPEN_LONG"
    OPEN_SHORT = "OPEN_SHORT"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"
    HOLD = "HOLD"


class SignalConfidence(str, Enum):
    """Confidence levels for signals."""

    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"


class Signal(BaseModel):
    """Base trading signal model."""

    symbol: str = Field(..., description="Trading symbol")
    signal_type: SignalType = Field(..., description="Signal type")
    signal_action: SignalAction = Field(..., description="Signal action")
    confidence: SignalConfidence = Field(..., description="Signal confidence")
    confidence_score: float = Field(
        ..., ge=0.0, le=1.0, description="Confidence score (0-1)"
    )
    price: float = Field(..., gt=0, description="Current price")
    timestamp: datetime = Field(
        default_factory=datetime.utcnow, description="Signal timestamp"
    )
    strategy_name: str = Field(..., description="Strategy that generated the signal")
    metadata: dict[str, Any] = Field(
        default_factory=dict, description="Additional metadata"
    )

    @validator("symbol")
    def validate_symbol(cls, v):
        """Validate trading symbol format."""
        if not v or len(v) < 6:
            raise ValueError("Invalid symbol format")
        return v.upper()

    @validator("confidence_score")
    def validate_confidence_score(cls, v):
        """Validate confidence score is between 0 and 1."""
        if not 0.0 <= v <= 1.0:
            raise ValueError("Confidence score must be between 0.0 and 1.0")
        return v

    @property
    def is_buy_signal(self) -> bool:
        """Check if this is a buy signal."""
        return self.signal_type == SignalType.BUY

    @property
    def is_sell_signal(self) -> bool:
        """Check if this is a sell signal."""
        return self.signal_type == SignalType.SELL

    @property
    def is_hold_signal(self) -> bool:
        """Check if this is a hold signal."""
        return self.signal_type == SignalType.HOLD

    @property
    def is_high_confidence(self) -> bool:
        """Check if this is a high confidence signal."""
        return self.confidence == SignalConfidence.HIGH

    @property
    def is_medium_confidence(self) -> bool:
        """Check if this is a medium confidence signal."""
        return self.confidence == SignalConfidence.MEDIUM

    @property
    def is_low_confidence(self) -> bool:
        """Check if this is a low confidence signal."""
        return self.confidence == SignalConfidence.LOW


class StrategySignal(BaseModel):
    """Signal generated by a specific strategy."""

    signal: Signal = Field(..., description="Base signal")
    strategy_version: str = Field(..., description="Strategy version")
    strategy_parameters: dict[str, Any] = Field(
        default_factory=dict, description="Strategy parameters"
    )
    input_data: dict[str, Any] = Field(
        default_factory=dict, description="Input data used by strategy"
    )
    processing_time_ms: float = Field(
        ..., ge=0, description="Processing time in milliseconds"
    )
    strategy_specific_metrics: dict[str, float] = Field(
        default_factory=dict, description="Strategy-specific metrics"
    )

    @property
    def symbol(self) -> str:
        """Get symbol from underlying signal."""
        return self.signal.symbol

    @property
    def signal_type(self) -> SignalType:
        """Get signal type from underlying signal."""
        return self.signal.signal_type

    @property
    def confidence_score(self) -> float:
        """Get confidence score from underlying signal."""
        return self.signal.confidence_score

    @property
    def timestamp(self) -> datetime:
        """Get timestamp from underlying signal."""
        return self.signal.timestamp


class SignalAggregation(BaseModel):
    """Aggregated signals from multiple strategies."""

    symbol: str = Field(..., description="Trading symbol")
    aggregated_signal_type: SignalType = Field(
        ..., description="Aggregated signal type"
    )
    aggregated_signal_action: SignalAction = Field(
        ..., description="Aggregated signal action"
    )
    aggregated_confidence_score: float = Field(
        ..., ge=0.0, le=1.0, description="Aggregated confidence score"
    )
    aggregated_confidence: SignalConfidence = Field(
        ..., description="Aggregated confidence level"
    )
    strategy_signals: dict[str, StrategySignal] = Field(
        ..., description="Individual strategy signals"
    )
    aggregation_method: str = Field(..., description="Method used for aggregation")
    aggregation_weights: dict[str, float] = Field(
        default_factory=dict, description="Weights used for aggregation"
    )
    timestamp: datetime = Field(
        default_factory=datetime.utcnow, description="Aggregation timestamp"
    )
    metadata: dict[str, Any] = Field(
        default_factory=dict, description="Additional metadata"
    )

    @validator("symbol")
    def validate_symbol(cls, v):
        """Validate trading symbol format."""
        if not v or len(v) < 6:
            raise ValueError("Invalid symbol format")
        return v.upper()

    @validator("aggregated_confidence_score")
    def validate_confidence_score(cls, v):
        """Validate confidence score is between 0 and 1."""
        if not 0.0 <= v <= 1.0:
            raise ValueError("Confidence score must be between 0.0 and 1.0")
        return v

    @property
    def strategy_count(self) -> int:
        """Get number of strategies that generated signals."""
        return len(self.strategy_signals)

    @property
    def average_confidence_score(self) -> float:
        """Calculate average confidence score across all strategies."""
        if not self.strategy_signals:
            return 0.0
        scores = [signal.confidence_score for signal in self.strategy_signals.values()]
        return sum(scores) / len(scores)

    @property
    def consensus_signal_type(self) -> Optional[SignalType]:
        """Get consensus signal type (most common)."""
        if not self.strategy_signals:
            return None

        signal_types = [signal.signal_type for signal in self.strategy_signals.values()]
        signal_type_counts = {}
        for signal_type in signal_types:
            signal_type_counts[signal_type] = signal_type_counts.get(signal_type, 0) + 1

        return max(signal_type_counts, key=signal_type_counts.get)

    @property
    def is_strong_consensus(self) -> bool:
        """Check if there is strong consensus among strategies."""
        if not self.strategy_signals:
            return False

        consensus_type = self.consensus_signal_type
        if not consensus_type:
            return False

        consensus_count = sum(
            1
            for signal in self.strategy_signals.values()
            if signal.signal_type == consensus_type
        )

        return (
            consensus_count >= len(self.strategy_signals) * 0.7
        )  # 70% consensus threshold


class SignalMetrics(BaseModel):
    """Metrics for signal generation and performance."""

    total_signals_generated: int = Field(
        default=0, description="Total signals generated"
    )
    signals_by_type: dict[SignalType, int] = Field(
        default_factory=dict, description="Signals by type"
    )
    signals_by_confidence: dict[SignalConfidence, int] = Field(
        default_factory=dict, description="Signals by confidence"
    )
    signals_by_strategy: dict[str, int] = Field(
        default_factory=dict, description="Signals by strategy"
    )
    average_processing_time_ms: float = Field(
        default=0.0, description="Average processing time"
    )
    signal_generation_rate: float = Field(default=0.0, description="Signals per second")
    last_signal_timestamp: Optional[datetime] = Field(
        default=None, description="Last signal timestamp"
    )
    metadata: dict[str, Any] = Field(
        default_factory=dict, description="Additional metrics"
    )

    def update_metrics(self, signal: Signal, processing_time_ms: float) -> None:
        """Update metrics with a new signal."""
        self.total_signals_generated += 1

        # Update signals by type
        self.signals_by_type[signal.signal_type] = (
            self.signals_by_type.get(signal.signal_type, 0) + 1
        )

        # Update signals by confidence
        self.signals_by_confidence[signal.confidence] = (
            self.signals_by_confidence.get(signal.confidence, 0) + 1
        )

        # Update signals by strategy
        self.signals_by_strategy[signal.strategy_name] = (
            self.signals_by_strategy.get(signal.strategy_name, 0) + 1
        )

        # Update processing time
        if self.total_signals_generated == 1:
            self.average_processing_time_ms = processing_time_ms
        else:
            self.average_processing_time_ms = (
                self.average_processing_time_ms * (self.total_signals_generated - 1)
                + processing_time_ms
            ) / self.total_signals_generated

        # Update last signal timestamp
        self.last_signal_timestamp = signal.timestamp

    def get_signal_distribution(self) -> dict[str, float]:
        """Get signal distribution percentages."""
        if self.total_signals_generated == 0:
            return {}

        distribution = {}

        # Signal type distribution
        for signal_type, count in self.signals_by_type.items():
            distribution[f"type_{signal_type.value.lower()}"] = (
                count / self.total_signals_generated
            )

        # Confidence distribution
        for confidence, count in self.signals_by_confidence.items():
            distribution[f"confidence_{confidence.value.lower()}"] = (
                count / self.total_signals_generated
            )

        # Strategy distribution
        for strategy, count in self.signals_by_strategy.items():
            distribution[f"strategy_{strategy}"] = count / self.total_signals_generated

        return distribution

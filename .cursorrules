# MASTER RULES: See petrosa_k8s/.cursorrules

**IMPORTANT**: This file contains service-specific rules only. For ecosystem-wide rules, architecture, shared resources, deployment patterns, and cross-service integration, always refer to:
- **Master Cursorrules**: `/Users/yurisa2/petrosa/petrosa_k8s/.cursorrules`

When working on this service, read the master cursorrules first to understand the full system context.

---

## Realtime Strategies - Satellite Rules

### Service Context

The **Petrosa Realtime Strategies** service is a horizontally scalable, stateless signal generation engine that processes real-time market data from NATS and generates trading signals using multiple strategies. Unlike the TA Bot which analyzes historical data from MySQL, this service operates on **streaming data** with **zero state** between messages, enabling linear scalability through NATS consumer groups.

This service implements **3 core stateless strategies**: Order Book Skew, Trade Momentum, and Ticker Velocity. Each message is processed independently, and **3-10 replicas** can run concurrently via HPA (Horizontal Pod Autoscaler), with NATS automatically load-balancing messages across instances.

Additionally, this service exposes a **Runtime Configuration API** for live parameter tuning and a **Market Metrics API** for order book depth analytics, enabling dynamic strategy optimization without redeployment.

### Cross-References to Master

- **Ecosystem Architecture**: See master § System Architecture Overview → Signal Generation Layer
- **Work Tracking**: See master § Centralized Work Tracking with GitHub Projects
- **GitHub CLI Profile**: See master § Prerequisites & Installation → GitHub CLI Profile Configuration (CRITICAL: Always use `yurisa2` profile)
- **NATS Topics**: See master § NATS Message Bus → `binance.websocket.data` (input), `intent.trading.*` (output)
- **Deployment Patterns**: See master § Realtime Strategies Configuration
- **Scaling Strategy**: See master § Deployment Patterns (horizontal scaling via NATS consumer groups)
- **Runtime Configuration**: See master § Configuration Management
- **Shared Resources**: See master § Shared Resources (ConfigMaps, Secrets)

---

## Service-Specific Rules

### Repository Structure

**Key Files**:
- `README.md` - Service documentation with configuration API details
- `Makefile` - Development commands
- `k8s/deployment.yaml` - Deployment with 3 replicas + HPA
- `strategies/core/` - Strategy implementations
- `strategies/api/` - FastAPI configuration server
- `strategies/metrics/` - Market metrics API

**Directory Layout**:
```
petrosa-realtime-strategies/
├── strategies/
│   ├── core/                  # Strategy implementations
│   │   ├── orderbook_skew.py
│   │   ├── trade_momentum.py
│   │   ├── ticker_velocity.py
│   │   └── consumer.py
│   ├── api/                   # Runtime configuration API
│   │   ├── config_routes.py
│   │   ├── metrics_routes.py
│   │   └── schemas.py
│   ├── models/                # Data models
│   │   ├── signal.py
│   │   └── market_data.py
│   └── db/                    # MongoDB for config persistence
│       └── config_store.py
└── k8s/
    ├── deployment.yaml        # 3 replicas
    ├── hpa.yaml               # Auto-scaling config
    └── service.yaml
```

### Stateless Design Principles

**Why Stateless Matters**:

1. **Linear Scalability**: Each replica processes independent subset of messages
2. **No Coordination**: No locks, no shared state, no race conditions
3. **Fault Tolerance**: Pod failure doesn't lose state (because there is none)
4. **Instant Recovery**: New pods immediately productive
5. **Simple Deployment**: No leader election, no state migration

**Stateless Strategy Example**:
```python
class OrderBookSkewStrategy:
    """
    Completely stateless - each message processed independently.
    No historical data, no moving windows, no state accumulation.
    """
    
    def analyze(self, depth_data: DepthUpdate) -> Optional[Signal]:
        """
        Analyze order book depth (stateless).
        
        Uses ONLY data from current message:
        - Top 5 bid levels
        - Top 5 ask levels
        - Current spread
        
        No reference to previous messages or external state.
        """
        # Calculate bid volume (top N levels)
        bid_volume = sum(
            float(level.quantity)
            for level in depth_data.bids[:self.top_levels]
        )
        
        # Calculate ask volume (top N levels)
        ask_volume = sum(
            float(level.quantity)
            for level in depth_data.asks[:self.top_levels]
        )
        
        # Calculate ratio (stateless calculation)
        ratio = bid_volume / ask_volume if ask_volume > 0 else 0
        
        # Generate signal based on current state only
        if ratio > self.buy_threshold:
            return self._create_buy_signal(depth_data, ratio)
        elif ratio < self.sell_threshold:
            return self._create_sell_signal(depth_data, ratio)
        
        return None  # No signal
```

**Acceptable Minimal State**:

Only the **Ticker Velocity** strategy maintains minimal state (60-second price cache) for velocity calculation. This is acceptable because:
- Cache is per-symbol (independent)
- Bounded size (60 seconds of data)
- Automatically pruned (old entries removed)
- Loss is non-critical (strategy temporarily disabled until rebuilt)

### NATS Consumer Group Pattern

**Load Balancing**:
```python
# Each replica subscribes to same topic with same consumer group
# NATS automatically distributes messages across replicas

class NATSConsumer:
    def __init__(self):
        self.consumer_group = "realtime-strategies-group"  # Same for all replicas
        self.topic = "binance.websocket.data"
    
    async def _subscribe_to_topic(self):
        # Consumer group enables load balancing
        self.subscription = await self.nats_client.subscribe(
            self.topic,
            queue=self.consumer_group,  # CRITICAL: Enables distribution
            cb=self._message_handler
        )
```

**Message Distribution**:
```
NATS Topic: binance.websocket.data (1000+ msg/sec)
              ↓
   Consumer Group: realtime-strategies-group
              ↓
    ┌─────────┴─────────┐
    ↓         ↓         ↓
 Replica 1  Replica 2  Replica 3
 (333 msg/s) (333 msg/s) (333 msg/s)
```

**Deployment Configuration**:
```yaml
apiVersion: apps/v1
kind: Deployment
spec:
  replicas: 3  # Can scale 3-10 via HPA
  template:
    spec:
      containers:
      - name: realtime-strategies
        env:
        - name: NATS_CONSUMER_GROUP
          value: "realtime-strategies-group"  # Must be same across replicas
```

### Horizontal Pod Autoscaler (HPA)

**Auto-Scaling Configuration**:
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: realtime-strategies-hpa
spec:
  scaleTargetRef:
    kind: Deployment
    name: petrosa-realtime-strategies
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

**Scaling Behavior**:
- **Scale Up**: When CPU > 70% or Memory > 80%
- **Scale Down**: When CPU < 50% and Memory < 60% for 5 minutes
- **Scale Limits**: 3 (min) to 10 (max) replicas
- **Distribution**: NATS automatically rebalances messages

### Runtime Configuration API

**API Endpoints**:
```bash
# Get strategy configuration
GET /api/v1/strategies/{strategy_id}/config
GET /api/v1/strategies/{strategy_id}/config/{symbol}

# Update configuration
POST /api/v1/strategies/{strategy_id}/config
POST /api/v1/strategies/{strategy_id}/config/{symbol}

# Force cache refresh
POST /api/v1/strategies/cache/refresh

# Get audit trail
GET /api/v1/strategies/{strategy_id}/audit
```

**Configuration Example**:
```bash
# Update Order Book Skew strategy globally
curl -X POST http://realtime-strategies:8080/api/v1/strategies/orderbook_skew/config \
  -H "Content-Type: application/json" \
  -d '{
    "parameters": {
      "buy_threshold": 1.3,
      "sell_threshold": 0.75,
      "top_levels": 5
    },
    "changed_by": "admin",
    "reason": "Adjusting sensitivity for volatile market"
  }'

# Update for specific symbol (BTCUSDT only)
curl -X POST http://realtime-strategies:8080/api/v1/strategies/orderbook_skew/config/BTCUSDT \
  -H "Content-Type: application/json" \
  -d '{
    "parameters": {
      "buy_threshold": 1.5
    },
    "changed_by": "admin",
    "reason": "BTC has higher liquidity, needs higher threshold"
  }'
```

**Configuration Inheritance**:
```
Global Config: buy_threshold = 1.2 (applies to all symbols)
BTCUSDT Override: buy_threshold = 1.5 (only for BTC)
ETHUSDT: uses global 1.2 (no override)
```

**Swagger UI**: http://realtime-strategies:8080/docs

### Market Metrics API

**Endpoints**:
```bash
# Current depth metrics for symbol
GET /api/v1/metrics/depth/{symbol}

# Pressure history (5m, 15m, 1h timeframes)
GET /api/v1/metrics/pressure/{symbol}?timeframe=5m

# Market-wide summary
GET /api/v1/metrics/summary

# All symbols metrics
GET /api/v1/metrics/all
```

**Usage Examples**:
```bash
# Check BTC order book pressure
curl http://realtime-strategies:8080/api/v1/metrics/depth/BTCUSDT | jq '.pressure'

# Response:
{
  "buy_pressure": 65.5,     # 0-100 scale
  "sell_pressure": 34.5,
  "net_pressure": 31.0,     # Positive = bullish
  "interpretation": "bullish"
}

# Get 5-minute pressure trend
curl "http://realtime-strategies:8080/api/v1/metrics/pressure/BTCUSDT?timeframe=5m" | jq '.summary'

# Response:
{
  "avg_pressure": 25.5,
  "trend": "bullish",
  "trend_strength": 0.75    # 0-1 scale
}

# Overall market sentiment
curl http://realtime-strategies:8080/api/v1/metrics/summary | jq '.market_sentiment'

# Response:
{
  "bullish_symbols": 28,
  "bearish_symbols": 12,
  "neutral_symbols": 5,
  "avg_net_pressure": 15.5
}
```

### Strategy Implementations

**1. Order Book Skew Strategy**:
```python
class OrderBookSkewStrategy:
    """
    Analyze bid/ask imbalance for buying/selling pressure.
    
    Configurable Parameters (8):
    - top_levels: Number of levels to analyze (default: 5)
    - buy_threshold: Ratio for buy signal (default: 1.2)
    - sell_threshold: Ratio for sell signal (default: 0.8)
    - min_spread_percent: Filter wide spreads (default: 0.1)
    - base_confidence: Starting confidence (default: 0.70)
    - imbalance_weight: Weight of imbalance (default: 0.6)
    - spread_weight: Weight of spread (default: 0.4)
    - min_total_volume: Minimum volume threshold (default: 0.001)
    """
    
    def analyze(self, depth_data: DepthUpdate) -> Optional[Signal]:
        # Stateless analysis of current order book state
        pass
```

**2. Trade Momentum Strategy**:
```python
class TradeMomentumStrategy:
    """
    Analyze individual trades for momentum indicators.
    
    Weighted scoring:
    - Price movement: 40%
    - Quantity size: 30%
    - Maker/taker status: 30%
    
    Configurable Parameters (9):
    - price_weight: Price movement weight (default: 0.4)
    - quantity_weight: Quantity weight (default: 0.3)
    - maker_weight: Maker/taker weight (default: 0.3)
    - buy_threshold: Momentum for buy (default: 0.7)
    - sell_threshold: Momentum for sell (default: -0.7)
    - min_quantity: Filter small trades (default: 0.001)
    - base_confidence: Starting confidence (default: 0.68)
    - time_decay_seconds: Time decay factor (default: 300)
    - momentum_window: Trade window size (default: 10)
    """
    
    def analyze(self, trade_data: TradeData) -> Optional[Signal]:
        # Calculate momentum from single trade (stateless)
        pass
```

**3. Ticker Velocity Strategy**:
```python
class TickerVelocityStrategy:
    """
    Analyze price velocity over time windows.
    
    Tracks rate of change to detect acceleration/deceleration.
    
    Configurable Parameters (8):
    - time_window: Window size in seconds (default: 60)
    - buy_threshold: Velocity for buy (default: 0.5% per min)
    - sell_threshold: Velocity for sell (default: -0.5% per min)
    - min_price_change: Filter noise (default: 0.1%)
    - base_confidence: Starting confidence (default: 0.65)
    - acceleration_weight: Acceleration weight (default: 0.5)
    - volume_confirmation: Require volume confirmation (default: true)
    - min_volume_change: Min volume change % (default: 0.2)
    """
    
    def analyze(self, ticker_data: TickerData) -> Optional[Signal]:
        # Calculate velocity using 60-second cache (minimal state)
        pass
```

### Development Workflow

**Local Development**:
```bash
# Setup
make setup

# Run with local NATS
make run-local

# Run with specific strategy only
STRATEGY_ENABLED_ORDERBOOK_SKEW=true \
STRATEGY_ENABLED_TRADE_MOMENTUM=false \
STRATEGY_ENABLED_TICKER_VELOCITY=false \
python -m strategies.main
```

**Testing**:
```bash
# Unit tests (strategy logic)
pytest tests/unit/test_orderbook_skew.py -v

# Integration tests (NATS flow)
pytest tests/integration/test_nats_flow.py -v

# Configuration API tests
pytest tests/api/test_config_api.py -v
```

**Configuration Testing**:
```bash
# Test configuration API
curl http://localhost:8080/api/v1/strategies

# Update configuration
curl -X POST http://localhost:8080/api/v1/strategies/orderbook_skew/config \
  -H "Content-Type: application/json" \
  -d '{"parameters": {"buy_threshold": 1.5}, "changed_by": "test", "reason": "testing"}'

# Verify update
curl http://localhost:8080/api/v1/strategies/orderbook_skew/config | jq '.parameters.buy_threshold'
```

### Common Issues & Solutions

#### 1. Signals Not Generated

**Symptom**: No signals published to `intent.trading.*`

**Check**:
```bash
# Verify message consumption
kubectl logs -n petrosa-apps -l app=realtime-strategies | grep "messages_processed"

# Check strategy thresholds (might be too strict)
curl http://realtime-strategies:8080/api/v1/strategies/orderbook_skew/config

# Verify NATS connectivity
kubectl exec -it deployment/petrosa-realtime-strategies -n petrosa-apps -- nc -zv nats-server.nats 4222
```

**Solutions**:
```bash
# Lower thresholds temporarily
curl -X POST http://realtime-strategies:8080/api/v1/strategies/orderbook_skew/config \
  -d '{"parameters": {"buy_threshold": 1.1, "sell_threshold": 0.9}}'

# Check indicators calculation
kubectl logs -n petrosa-apps -l app=realtime-strategies | grep "indicators"
```

#### 2. Duplicate Signals

**Symptom**: Multiple identical signals for same condition

**Cause**: Consumer group misconfiguration

**Fix**:
```yaml
# Verify all replicas use same consumer group
env:
- name: NATS_CONSUMER_GROUP
  value: "realtime-strategies-group"  # Must be identical
```

#### 3. High Memory Usage

**Symptom**: Memory increasing over time

**Check**:
```bash
# Check ticker velocity cache size
curl http://realtime-strategies:8080/api/v1/metrics/cache-stats

# Monitor per-pod memory
kubectl top pods -n petrosa-apps -l app=realtime-strategies
```

**Solutions**:
```yaml
# Reduce cache window
env:
- name: TICKER_VELOCITY_TIME_WINDOW
  value: "30"  # Reduce from 60 seconds
```

### Configuration

**Environment Variables** (service-specific):
```bash
# NATS configuration
NATS_CONSUMER_TOPIC="binance.websocket.data"
NATS_PUBLISHER_TOPIC="intent.trading.*"
NATS_CONSUMER_GROUP="realtime-strategies-group"  # CRITICAL for load balancing

# Trading symbols
TRADING_SYMBOLS="BTCUSDT,ETHUSDT,BNBUSDT"

# Database (for configuration persistence)
MONGODB_URI="mongodb://mongodb:27017"
MONGODB_DATABASE="petrosa"
MYSQL_URI="mysql+pymysql://user:pass@host:3306/db"  # Fallback

# Strategy toggles
STRATEGY_ENABLED_ORDERBOOK_SKEW=true
STRATEGY_ENABLED_TRADE_MOMENTUM=true
STRATEGY_ENABLED_TICKER_VELOCITY=true

# Runtime configuration
CONFIG_CACHE_TTL_SECONDS=60   # Config cache TTL
FASTAPI_PORT=8080              # API server port
HEARTBEAT_INTERVAL_SECONDS=60  # Heartbeat logging

# Strategy thresholds (can be overridden via API)
ORDERBOOK_SKEW_BUY_THRESHOLD=1.2
ORDERBOOK_SKEW_SELL_THRESHOLD=0.8
TRADE_MOMENTUM_BUY_THRESHOLD=0.7
TICKER_VELOCITY_BUY_THRESHOLD=0.5
```

### Success Metrics

**Performance Targets**:
- Message processing: 333+ messages/second per replica
- Signal generation: 20-50 signals/day per strategy
- API response time: < 100ms (95th percentile)
- Configuration cache hit rate: > 99%

**Monitoring**:
```bash
# Check signal generation rate
curl http://realtime-strategies:8080/api/v1/metrics/signals

# Monitor consumer group distribution
kubectl logs -n petrosa-apps -l app=realtime-strategies | grep "consumer_group"
```

### Always Reference

- For ecosystem-wide rules and patterns: **See master cursorrules**
- For work tracking and issue creation: **See master § Centralized Work Tracking with GitHub Projects**
- For NATS topics and message formats: **See master § NATS Message Bus**
- For deployment and HPA configuration: **See master § Realtime Strategies Configuration**
- For configuration management patterns: **See master § Configuration Management**
- For pre-merge cleanup: **See master § Pre-Merge Intelligent Cleanup Workflow** - Cursor AI automatically reorganizes files, removes outdated content, and consolidates documentation before merges using semantic understanding
